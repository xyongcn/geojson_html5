<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Maps &ndash; Wanli Yang</title>
	<link rel="stylesheet" href="geojson_html5-master/stylesheets/maps.css" />
</head>
<body>
	<h1>GeoJSON AND IMAGE MAP</h1>

	<div id="map">
		<button id="zoom-out">zoom out - </button>
	    <button id="zoom-in">zoom in + </button>
	</div>

	<script src="geojson_html5-master/javascript/storage.js"></script>
	<script src="geojson_html5-master/javascript/jquery.js"></script>
	<script src="geojson_html5-master/stylesheets/highway.js"></script>
	<script src="geojson_html5-master/stylesheets/water.js"></script>
	<script src="geojson_html5-master/stylesheets/building.js"></script>
	<script src="geojson_html5-master/stylesheets/railway.js"></script>
	<script>
	var $ = jQuery; //jquery框架
/*
Map主函数
参数：[div id="map"] [,zoom] [,x] [,y] 即地图中心切片位置：zoom/x/y
功能：地图初始化；地图操作-事件函数（鼠标滚动、缩放、移动）
*/
	var Map = function(div,zoom,x,y) {  //Map主函数功能
		this.$div = $(div);

		this.scale = 256;

		this.data = null;

		this.streets = new Array();

		// 增加画布 canvas
		this.$canvas = $("<canvas id='map-canvas'></canvas>");
		this.$canvas[0].width = this.$div.width();
		this.$canvas[0].height = this.$div.height();

		this.$div.append(this.$canvas);

		// 注册事件函数 events
		var _this = this;
		document.getElementById('zoom-in').onclick = function() {
		    zoom=zoom+1;
			x=2*x;
			y=2*y;
			changeCenter=1;
			_this.draw_Image(zoom,x,y);
		};

		document.getElementById('zoom-out').onclick = function() {
		    zoom=zoom-1;
			x=Math.round(x/2);
			y=Math.round(y/2);
			changeCenter=1;
			_this.draw_Image(zoom,x,y);
		};

		$(window).on('resize', function() {
			clearTimeout(_this.resizeTimeout);
			_this.resizeTimeout = setTimeout(function() {
				//_this.draw();
				_this.draw_Image(zoom,x,y);
			}, 500);
		});
	
		this.$canvas.on('mousewheel', function(event) { //鼠标滚动实现缩放功能
			//_this.scale = Math.max(100, _this.scale - event.originalEvent.deltaY / 2);
			if(event.originalEvent.deltaY>0){ //向上滚动-放大一个等级
				zoom=zoom+1;
				x=2*x;
				y=2*y;
				changeCenter=1;
				_this.draw_Image(zoom,x,y); //地图切片渲染函数
			}
			if(event.originalEvent.deltaY<0){ //向下滚动-缩小一个等级
				zoom=zoom-1;
				x=Math.round(x/2);
				y=Math.round(y/2);
				changeCenter=1;
				_this.draw_Image(zoom,x,y); //地图切片渲染函数
			}
		});
	
//mobile touch events
		this.$canvas.on('touchstart', function(event) { //鼠标点拖动-实现地图拖拽功能
			_this.last_position = { //鼠标点击的位置
				x: event.originalEvent.touches[0].clientX,
				y: event.originalEvent.touches[0].clientY
			};

			$(this).bind('touchmove', function(event) {
				var addX = 0;
				var addY = 0;
				var delta = { //位移长度
					x: _this.last_position.x - event.originalEvent.touches[0].clientX,
					y: _this.last_position.y - event.originalEvent.touches[0].clientY
				};

				 eventX -=delta.x; //位移后的新位置
				 eventY -=delta.y; //位移后的新位置

				 _this.last_position = { //当前位置初始化
				 	x: event.originalEvent.touches[0].clientX,
				 	y: event.originalEvent.touches[0].clientY
				 };	
				 
				 //向右或向左水平位移超过256（一个切片的宽度）
				 if((eventX>=256 && eventY<256 && eventY>-256)|| (eventX<=-256 && eventY<256 && eventY>-256)) {

				 	addX = parseInt(eventX/256);
				 	x=x-addX;
				 	//_this.draw_Image(zoom,x,y);
				 	changeCenter=1;//变换中心
				 	
				 }
				 //向上或向下水平位移超过256（一个切片的高度）
				 if((eventY>=256 && eventX<256 && eventX>-256)|| (eventY<=-256 && eventX<256 && eventX>-256)) {

				 	addY = parseInt(eventY/256);
				 	y=y-addY;
				 	//_this.draw_Image(zoom,x,y);
				 	changeCenter=1;
				 }
				 //向对角四个方向位移超过256
				 if((eventY>=256 && eventX>=256)|| (eventY<=-256 && eventX<=-256) || (eventY>=256 && eventX<=-256)|| (eventY<=-256 && eventX>=256)) {

				 	addY = parseInt(eventY/256);
				 	addX = parseInt(eventX/256);
				 	x=x-addX;
				 	y=y-addY;
				 	changeCenter=1;
				 	//_this.draw_Image(zoom,x,y);
				 }

				 _this.draw_Image(zoom,x,y);
				 
				});
		});

		this.$canvas.on('touchend', function(event) { //鼠标拖动结束事件函数
			$(this).unbind('touchmove');
		})

//desktop browser
		this.$canvas.on('mousedown', function(event) { //鼠标点拖动-实现地图拖拽功能
			_this.last_position = { //鼠标点击的位置
				x: event.clientX,
				y: event.clientY
			};

			$(this).bind('mousemove', function(event) {
				var addX = 0;
				var addY = 0;
				var delta = { //位移长度
					x: _this.last_position.x - event.clientX,
					y: _this.last_position.y - event.clientY
				};

				 eventX -=delta.x; //位移后的新位置
				 eventY -=delta.y; //位移后的新位置

				 _this.last_position = { //当前位置初始化
				 	x: event.clientX,
				 	y: event.clientY
				 };	
				 
				 //向右或向左水平位移超过256（一个切片的宽度）
				 if((eventX>=256 && eventY<256 && eventY>-256)|| (eventX<=-256 && eventY<256 && eventY>-256)) {

				 	addX = parseInt(eventX/256);
				 	x=x-addX;
				 	//_this.draw_Image(zoom,x,y);
				 	changeCenter=1;//变换中心
				 	
				 }
				 //向上或向下水平位移超过256（一个切片的高度）
				 if((eventY>=256 && eventX<256 && eventX>-256)|| (eventY<=-256 && eventX<256 && eventX>-256)) {

				 	addY = parseInt(eventY/256);
				 	y=y-addY;
				 	//_this.draw_Image(zoom,x,y);
				 	changeCenter=1;
				 }
				 //向对角四个方向位移超过256
				 if((eventY>=256 && eventX>=256)|| (eventY<=-256 && eventX<=-256) || (eventY>=256 && eventX<=-256)|| (eventY<=-256 && eventX>=256)) {

				 	addY = parseInt(eventY/256);
				 	addX = parseInt(eventX/256);
				 	x=x-addX;
				 	y=y-addY;
				 	changeCenter=1;
				 	//_this.draw_Image(zoom,x,y);
				 }

				if(eventX>50 || eventY>50 || eventX<-50 || eventY<-50) _this.draw_Image(zoom,x,y);
				 
				});
		});

		this.$canvas.on('mouseup', function(event) { //鼠标拖动结束事件函数
			$(this).unbind('mousemove');
		})

		return this;
		}; // Map div function -地图操

/*
Map主函数的原型方法-加载GeoJSON数据

load()-加载json数据-同步加载（即数据加载完成后再执行它之后的程序）
loadAsync()-加载json数据-异步加载（即数据加载同时可以先执行它之后的程序，加载完成进行回调）
*/
		Map.prototype.load = function(jsonTile) { 
			var _this = this;
			$.ajaxSettings.async = false; //ajax同步
			$.getJSON(jsonTile, function(data,textStatus) { //用jquery的getJSON()方法获取GeoJSON数据
				if(textStatus=="success")
				{
					_this.data = data;
					$(_this).trigger('data_updated');
					
				}				
			});
		};

		Map.prototype.loadAsync = function(jsonTile) {
			var _this = this;
			//$.ajaxSettings.async = false; //ajax异步
			$.getJSON(jsonTile, function(data,textStatus) { //用jquery的getJSON()方法获取GeoJSON数据
				if(textStatus=="success")
				{
					_this.data = data;
					$(_this).trigger('data_updated');
					
				}
			});
		};

/*
Map主函数的原型方法-渲染GeoJSON数据
参数：[ct]canvas元素，[jsonTile]GeoJSON切片数据 [zoom] [,x] [,y]zoom/x/y [moveX] [,moveY]canvas中的位置
功能：根据渲染规则读GeoJSON数据并进行渲染
*/
		Map.prototype.draw_json = function(ct,TileNum,zoom,x,y,moveX,moveY) {
			var ctx = ct;

			//坐标缩放权值
			var xmult = this.scale / (bbox[2] - bbox[0]);
			var ymult = this.scale / (bbox[3] - bbox[1]);

			var m = new Array; //道路填充位置x
			var n = new Array; //道路填充位置y
			var way_name = new Array; //道路名字 数组
			/*
			后期可以帮道路名字栅格化，进行图层叠加
			道路名字栅格化填充函数
			...add

			*/

			var num = 0; //道路名字出行次数
			
			//geojson数据对象格式（'LineString'、'MultiLineString'、'Polygon'、'MultiPolygon'）-对应格式： 一维数组 二维数组
			var coordinates = new Array; 

			function tile2lon(zoom, x) { //地理坐标-经度转换函数
			return (x / Math.pow(2, zoom) * 360 - 180);
			}

			function tile2lat(zoom, y) { //地理坐标-纬度转换函数
				var n = Math.PI - (2 * Math.PI * y) / Math.pow(2, zoom);
				return (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
			}

			//var bbox = new Array; 切片的边框的经纬度信息
			bbox[0]= tile2lon(zoom, x);
			bbox[3]= tile2lat(zoom, y);
			bbox[2]= tile2lon(zoom, x+1);
			bbox[1]= tile2lat(zoom, y+1);

			//geojson数据对象格式（'LineString'、'MultiLineString'、'Polygon'、'MultiPolygon'）-对应格式： 一维数组 二维数组			
			 $.each(store[TileNum].get('features'), function(indx, obj) { 
			 //解析json对象的jquery each()方法

			 	if (obj.geometry.type === 'LineString' ){
			 		coordinates=obj.geometry.coordinates;
			 	}
			 	if (obj.geometry.type === 'MultiLineString' || obj.geometry.type === 'Polygon' ){
			 		coordinates=obj.geometry.coordinates[0];
			 	}
			 	if (obj.geometry.type === 'MultiPolygon' ){
			 		coordinates=obj.geometry.coordinates[0][0];
			 	}

			 	//矢量绘制初始化
			 	ctx.beginPath();

			 	var hasInRange = false;
			 	$.each(coordinates, function(nindx, node) {
			 		if ((node[0] >= Math.min(bbox[0], bbox[2]) && node[0] <= Math.max(bbox[0], bbox[2]))&&(node[1] >= Math.min(bbox[1], bbox[3]) && node[1] <= Math.max(bbox[1], bbox[3]))) { hasInRange = true };
					//判断该点是否在切片范围内

					if(hasInRange) { //如果该点在切片范围内
						var x_ = (node[0] - bbox[0]) * xmult + moveX; //投影至画布上的x轴坐标
				 		var y_ = (bbox[3] - node[1]) * ymult + moveY; //投影至画布上的y轴坐标

				 		if (nindx === 0) { //矢量对象的起点
				 			ctx.moveTo(x_, y_); //canvas函数 绘制线条
				 			//if(obj.properties.name != undefined) {  //全部对象的名字
				 			if(obj.properties.name != undefined && obj.properties.highway != undefined && obj.properties.highway != null){ 
				 					m[num]=x_;
				 					n[num]=y_;
				 					way_name[num]=obj.properties.name; //道路名字
				 					num += 1;
				 				}

								//ctx.fillText=(obj.properties.name,m,n);
							}
						else {ctx.lineTo(x_, y_);} //canvas函数-绘制线条
					}
			 		
					//ctx.fillText(way_name[num],m[num],n[num]); 

				});

			 	if (!hasInRange) { return; };

			 	if(obj.properties.highway != undefined && obj.properties.highway != null) {
			 		//根据道路渲染规则"stylesheets/highway.js" 初始化道路对象
			 		var roads = new highwayCss('highway',obj.properties.highway,14);

			 		ctx.lineJoin="round";
					ctx.strokeStyle = roads[0]; //线条颜色
					ctx.lineWidth = roads[2];   //线条宽度
					//ctx.strokeDasharray = 5,10;
					ctx.stroke();               //绘制线条1（道路外围线）

					ctx.lineJoin="round";
					ctx.strokeStyle = roads[1]; //线条颜色
					ctx.lineWidth = roads[3];   //线条宽度
					ctx.stroke();               //绘制线条2 （道路主线-内）
			 		
			};//if type==way end

            //building water area
            
            if(obj.properties["building"] != null) {
            	//根据建筑渲染规则"stylesheets/building.js" 初始化建筑对象
            	var building = new buildingCss('building',obj.properties.building,14);
            	ctx.strokeStyle = building[0];
            	ctx.fillStyle = building[1];
            	ctx.lineWidth = building[2];
            	ctx.fill();
            	ctx.stroke();
            }

            if(obj.properties.water != null) {
            	//根据水域渲染规则"stylesheets/water.js" 初始化水域对象
            	var water = new waterCss('water',obj.properties,14);
            	ctx.fillStyle = water[1];
            	ctx.globalAlpha = 0.9; 
            	ctx.fill();
            	//ctx.stroke();
            }

            if(obj.properties.waterway === 'river'){
            	//根据河流渲染规则"stylesheets/waterway.js" 初始化河流对象
            	var waterway = new waterCss('waterway',obj.properties,14);
            	ctx.strokeStyle = waterway[0];
            	ctx.lineWidth = waterway[2];
            	ctx.stroke();
            }

            if(obj.properties.railway === 'subway'){
            	//根据水域渲染规则"stylesheets/subway.js" 初始化地铁对象
            	var railway = new railwayCss('subway',obj.properties,14);
            	if(railway[6]==0) //非虚线
            	{
	            	ctx.strokeStyle = railway[0];
	            	ctx.lineWidth = railway[1];
	            	ctx.stroke();

	            	ctx.strokeStyle = railway[2];
	            	ctx.lineWidth = railway[3];
	            	ctx.stroke();
	            	
	            	ctx.strokeStyle = railway[4];
	            	ctx.lineWidth = railway[5];
	            	ctx.stroke();
            	}
            	if(railway[6]==1) //画虚线
            	{
	            	ctx.strokeStyle = railway[0];
	            	ctx.lineWidth = railway[1];
	            	ctx.stroke();
	            }
            	
            }

            ctx.fillStyle = 'black';
					//ctx.fillText(num,m[num-1],n[num-1]);
			}); // .each(this.data.features, function(indx, way)

			
			/*
			后期可以帮道路名字栅格化，进行图层叠加
			道路名字栅格化填充函数
			...add

			*/
			//填充道路名字
			for (var i = 0; i < way_name.length; i++) {
				ctx.strokeStyle = 'black';
				ctx.fillstyle = 'black';
				ctx.font="10px Arial";
				ctx.textBaseline="middle";
				ctx.textAlign = "center";
				if(i%3==0) ctx.fillText(way_name[i],m[i],n[i]);
				//相同路名只显示一次
				for (var j = i; j <way_name.length; j++) {
					if(way_name[j]==way_name[j+1]) j++;
					else{
						i=j; 
						i++;
						break;
					}
				};
			}; 
		}
/*
Map主函数的原型方法-地图混合渲染函数
参数：[zoom] [,x] [,y]zoom/x/y 切片块位置（命名：缩放等级/x/y）
功能：根据渲染规则读GeoJSON数据并进行渲染
*/

		// render MAP
		Map.prototype.draw_Image = function(zoom,x,y){
			//初始化工作
			var _this = this;
			var ctx = this.$canvas[0].getContext('2d');

			this.$canvas[0].width = this.$div.width();
			this.$canvas[0].height = this.$div.height();
			ctx.width = this.$div.width();
			ctx.height = this.$div.height();

			var pngTile = new Array();  //图片切片
			var jsonTile = new Array(); //矢量切片
			var jsonT = new Array(); //矢量切片
			// Create or get an existing store


		/*
			for(var i = 0; i < 35 ; i++){
				pngTile[i] = new Image();
				pngTile[i].addEventListener('load',eventImageLoad,false);
			}
		*/
			var move_x = new Array(); //切片的7个横坐标位置
			var move_y = new Array(); //切片的5个纵坐标位置


			for (var i = 0; i < 7; i++) {
				move_y[i] = 256*(i-1); //切片的5个纵坐标位置初始化
			};	

			for (var i = 0; i < 7; i++) {
				move_x[i] = 256*(i-1); ////切片的7个横坐标位置初始化
				for (var j = 0; j < 7 ; j++) {
					//图像切片命名 - 文件路径
					pngTile[7*i+j] = zoom+'/'+(x-3+i)+'/'+(y-3+j); 
					//本地矢量切片命名 - 文件路径
					//jsonTile[7*i+j] =''+'Tiles'+'/'+zoom+'/'+(x-3+i)+'/'+(y-3+j)+'.'+'json'; 
				};
			};
/*
			function eventImageLoad(){
				drawScreen();
			}
*/
			function drawScreen(){
				     
				     //切片位置视图
			//	 0   1  2   3   4   5    6
			//0	[0   5  10  15  20  25   30]
			//1	[1  [6  11  16  21  26]  31]
			//2	[2  [7  12  17  22  27]  32]
			//3	[3  [8  13  18  23  28]  33]
			//4	[4   9  14  19  24  29   34]


					 //切片位置视图
			//	 0   1  2   3   4   5    6
			//0	[0   7  14  21  28  35   42]
			//1	[1  [8  15  22  29  36]  43]
			//2	[2  [9  16  23  30  37]  44]
			//3	[3  [10 17  24  31  38]  45]
			//4	[4  [11 18  25  32  39]  46]
			//5	[5  [12 19  26  33  40]  47]
			//6	[6   13 20  27  34  41   48]

				if(changeCenter==1) { //触发中心点位置修正
					move_x[3]=move_x[3]+eventX;
					move_y[2]=move_y[2]+eventY;
					eventX=0;
					eventY=0;
					
					for(var i=0;i<49;i++){
						jsonTile[i]=url1+'v/'+pngTile[i];
						store[i] = Storage('store['+i+']');
						//map.load(jsonTile[i]);

						$.ajaxSettings.async = false; //ajax同步
						$.getJSON(jsonTile[i], function(data,textStatus) { //用jquery的getJSON()方法获取GeoJSON数据
							if(textStatus=="success")
							{
								if(store[i].name == 'QuotaExceededError'){
									store[i].clear();
									store[i].set('features',data.features);
								}
								else store[i].set('features',data.features);
								$(_this).trigger('data_updated');
							}	
						});

						//store[i].set('features',_this.data.features);

						changeCenter=0;
					}
									
				}
				var img = new Array();
				//url1="http://10.108.21.81/geoserver/";
				//url2="http://otile2.mqcdn.com/tiles/1.0.0/osm/"
				function Tilefunction(TileNum,zz,xx,yy,canvasX,canvasY)
				{
					var img16 = new Image();
					img16.onload = function(){
						ctx.drawImage(img16,canvasX+eventX,canvasY+eventY);
					};
					img16.onerror = function(){
						map.draw_json(ctx,TileNum,zz,xx,yy,canvasX+eventX,canvasY+eventY);
					}
					img16.src=url1+'i/'+pngTile[TileNum];			
				}
				var countTile=0;
				for (var i = 0; i < 7; i++) {
					for(var j = 0; j < 7; j++){
						Tilefunction(countTile++,zoom,x-3+i,y-3+j,move_x[i],move_y[j]);
					}
					
				};


				//Tilefunction(TileNum,zz,xx,yy,canvasX,canvasY)
/*				
				Tilefunction(16,zoom,x,y-1,move_x[3],move_y[1]);
				Tilefunction(17,zoom,x,y,  move_x[3],move_y[2]);
				Tilefunction(18,zoom,x,y+1,move_x[3],move_y[3]);

				Tilefunction(11,zoom,x-1,y-1,move_x[2],move_y[1]);
				Tilefunction(12,zoom,x-1,y,  move_x[2],move_y[2]);
				Tilefunction(13,zoom,x-1,y+1,move_x[2],move_y[3]);

				Tilefunction(21,zoom,x+1,y-1,move_x[4],move_y[1]);
				Tilefunction(22,zoom,x+1,y,  move_x[4],move_y[2]);
				Tilefunction(23,zoom,x+1,y+1,move_x[4],move_y[3]);

				Tilefunction(6,zoom,x-2,y-1,move_x[1],move_y[1]);
				Tilefunction(7,zoom,x-2,y,  move_x[1],move_y[2]);
				Tilefunction(8,zoom,x-2,y+1,move_x[1],move_y[3]);

				Tilefunction(26,zoom,x+2,y-1,move_x[5],move_y[1]);
				Tilefunction(27,zoom,x+2,y,  move_x[5],move_y[2]);
				Tilefunction(28,zoom,x+2,y+1,move_x[5],move_y[3]);

				Tilefunction(0,zoom,x-3,y-2,move_x[0],move_y[0]);
				Tilefunction(1,zoom,x-3,y-1,move_x[0],move_y[1]);
				Tilefunction(2,zoom,x-3,y,  move_x[0],move_y[2]);
				Tilefunction(3,zoom,x-3,y+1,move_x[0],move_y[3]);
				Tilefunction(4,zoom,x-3,y+2,move_x[0],move_y[4]);

				Tilefunction(30,zoom,x+3,y-2,move_x[6],move_y[0]);
				Tilefunction(31,zoom,x+3,y-1,move_x[6],move_y[1]);
				Tilefunction(32,zoom,x+3,y,  move_x[6],move_y[2]);
				Tilefunction(33,zoom,x+3,y+1,move_x[6],move_y[3]);
				Tilefunction(34,zoom,x+3,y+2,move_x[6],move_y[4]);

				Tilefunction(5, zoom,x-2,y-2,move_x[1],move_y[0]);
				Tilefunction(10,zoom,x-1,y-2,move_x[2],move_y[0]);
				Tilefunction(15,zoom,x,y-2,  move_x[3],move_y[0]);
				Tilefunction(20,zoom,x+1,y-2,move_x[4],move_y[0]);
				Tilefunction(25,zoom,x+2,y-2,move_x[5],move_y[0]);

				Tilefunction(9, zoom,x-2,y+2,move_x[1],move_y[4]);
				Tilefunction(14,zoom,x-1,y+2,move_x[2],move_y[4]);
				Tilefunction(19,zoom,x,  y+2,move_x[3],move_y[4]);
				Tilefunction(24,zoom,x+1,y+2,move_x[4],move_y[4]);
				Tilefunction(29,zoom,x+2,y+2,move_x[5],move_y[4]);
*/

			}//drawScreen()

			drawScreen(); //混合显示


		}//draw_Image

/*
Map主函数的原型方法-切片z/x/y转bbox（1,2,3,4）边框经纬度
参数：[zoom] [,x] [,y]zoom/x/y 切片块位置（命名：缩放等级/x/y）
*/
		Map.prototype.tile2bbox = function(zoom,x,y) {

			function tile2lon(zoom, x) {
			return (x / Math.pow(2, zoom) * 360 - 180);
		}

		function tile2lat(zoom, y) {
			var n = Math.PI - (2 * Math.PI * y) / Math.pow(2, zoom);
			return (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
		}

		var bbox = new Array;
		bbox[0]= tile2lon(zoom, x);
		bbox[3]= tile2lat(zoom, y);
		bbox[2]= tile2lon(zoom, x+1);
		bbox[1]= tile2lat(zoom, y+1);

		} 
	</script>
	<script>
		//中心点的经纬度坐标及缩放等级
		var lon = 116.1520161816;    //经度
		var lat = 39.71115201618162; //纬度
		var zoom = 13;               //缩放等级
		
		function lon2tile(lon,zoom) { //经度转切片坐标x函数
			return (Math.floor((lon + 180) / 360 * Math.pow(2, zoom)));
		};
		function lat2tile(lat,zoom) { //纬度转切片坐标y函数 
			return (Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)));
		};

		var x = lon2tile(lon,zoom); //中心切片的x值
		var y = lat2tile(lat,zoom); //中心切片的y值

		var flag =0;  //地图数据源的信号函数 初始化为0；
		var changeCenter=1; //中心位置切片修正触发信号
		 
		//鼠标事件位移量初始化
		var eventX=0; 
		var eventY=0;

		// URL - 对应服务器
		var url1="http://10.108.21.81/geoserver/";	
		var url2 ="http://otile2.mqcdn.com/tiles/1.0.0/osm/";

		var store = new Array;

		//地图对象初始化
		var map = new Map(document.getElementById("map"),zoom,x,y);
		
		var bbox = new Array;     //切片边界数组
		map.draw_Image(zoom,x,y); //绘制地图

	</script>
</body>
</html>